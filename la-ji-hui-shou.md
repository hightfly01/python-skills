python采用的是`引用计数机制`为主，`标记-清除`和`分代收集`两种机制为辅的垃圾回收策略。

## 引用计数机制

```
class ClassA():
    def __init__(self):
        print 'object born,id:%s'%str(hex(id(self)))
    def __del__(self):
        print 'object del,id:%s'%str(hex(id(self)))

def f1():

    c1=ClassA()
    del c1
```

执行f1\(\)会输出这样的结果，而且进程占用的内存基本不会变动。

```
object born,id:0x237cf58
object del,id:0x237cf58
```

`c1=ClassA()`会创建一个对象，放在`0x237cf58`内存中，c1变量指向这个内存，这时候这个内存的引用计数是1。

`del c1`后，c1变量不再指向`0x237cf58`内存，所以这块内存的引用计数减一，等于0，所以就销毁了这个对象，然后释放内存。

#### 导致引用计数+1的情况：

* 对象被创建，例如`a=23`
* 对象被引用，例如`b=a`
* 对象被作为参数，传入到一个函数中，例如`func(a)`
* 对象作为一个元素，存储在容器中，例如`list1=[a,a]`

#### 导致引用计数-1的情况：

* 对象的别名被显式销毁，例如`del a`
* 对象的别名被赋予新的对象，例如`a=24`
* 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
* 对象所在的容器被销毁，或从容器中删除对象

#### 引用计数机制的优点：

* 简单

* 实时性：一旦没有引用，内存就直接释放了。实时性还带来一个好处：处理回收内存的时间分摊到了平时。

#### 引用计数机制的缺点：

* 维护引用计数消耗资源

* 循环引用导致内存泄漏

```
list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
```

## 标记-清除

![](/assets/Snip20180226_1.png)

首先初始`所有对象标记为白色`，并确定`根节点对象`（这些对象是不会被删除），`标记它们为黑色`（表示对象有效）。

将`有效对象引用的对象标记为灰色`（表示对象可达，但它们所引用的对象还没检查），检查完灰色对象引用的对象后，将灰色标记为黑色。重复直到不存在灰色节点为止。最后白色结点都是需要清除的对象。

## 分代收集

分代技术是一种典型的以空间换时间的技术。

这种技术就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。

分代就是将回收对象分成三代，每个代就是一个链表。

python创建一个新的对象，将其添加到零代链表中。当零代链表中对象个数超过最大容纳值时，Python会循环遍历零代链表上的每个对象，检查列表中每个互相引用的对象，根据规则减掉其引用计数。如果在零代链表中引用计数为0的对象，收集器可以释放它们并回收内存空间。如果在零代链表中对象有其它对象所引用并且有着更高的引用计数，向这样的活跃对象被移动到一代链表中。

一代链表：对于一代链表中的对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代链表。

